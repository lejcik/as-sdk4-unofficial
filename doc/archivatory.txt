Vše o pluginech typu archivátor pro Altap Salamander
====================================================
Autor: ALTAP, spol. s r.o.

Obsah
 1. Vznik a historie archivátorù
 2. Budoucnost archivátorù
 3. Hlavní a vedlejší funkce archivátorù
 4. Krátkı úvod do pluginù
 5. Instalace archivátorù do Salamandera
 6. Jak vidí archivátory uivatel Salamandera
 7. Rozdíly mezi archivátory a pluginy typu file systém
 8. Vrstvená architektura archivátoru a jejich engine
 9. ivotní cyklus pluginu
10. Úvod do implementace archivátoru
11. Drení listingu archivu: kontext
12. Optimalizované listování archivu
13. Vrstva Input/Output
14. Ošetøení vstupù a vıstupù: CSalamanderSafeFileAbstract    
15. Minimalizace fragmentování disku bìhem zápisu souborù
16. Èeho se vyvarovat bìhem implementace archivátoru
17. Testování archivátorù


1. Vznik a historie archivátorù
===============================
Archivátory, respektive packery a unpackery dnes tvoøí nejvìtší skupinu pluginù
Salamandera. Salamander ve verzi 1.52 (poslední freeware verze) archivátory
nepodporoval v ádné formì a uivatelé na nás vyvíjeli silnı tlak. Nejvìtší
poptávka byla po formátu ZIP, kterı je nejrošíøenìjším typem komprese.

Do verze 1.6 beta 1 (bøezen 1999) jsme implementovali podporu pro práci se ZIP 
archivy. Vše bylo øešeno v rámci jádra Salamandera s vyuitím knihoven zip32.dll
a unzip32.dll z freeware balíku InfoZIP. Tyto dvì knihovny se bìhem beta testování
ukázaly jako závanı zdroj chyb, z èásti pro jejich multiplatformní zamìøení. 
Zároveò byla pøipojena knihovna tardll.dll, zárodek budoucího pluginu TAR 
a knihovna pak.dll, která byla pozdìji pøevedena na plugin PAK.

Ve stejnou dobu jsme implementovali podporu pro externí archivátory. Externí
archivátory jsou postaveny na parsování listingù rùznıch pakovaèù volanıch z 
pøíkazové øádky. Tento pøístup pøináší mnohá úskalí, protoe externí archivátory
bìí jako samostatné procesy, narozdíl od pluginu bìícího v rámci procesu
Salamandera. Jejich ovladatelnost se tím prudce sniuje. Listingy se lišily 
verze od verze externího pakovaèe, mìnily se jeho návratové hodnoty, není 
moné zobrazovat progress bìhem pakování a rozpakování atd. 

Postupem èasu jsme nejpouívanìjší externí archivátory pøevedli na pluginy typu
archivátor. Externí archivátory jsou podporovány Salamanderem dodnes a jejich
hlavní tìištì spoèívá ve vytváøení archivù. Zatímco kód pro rozbalování a
procházení archivù je èasto free (a u formou zdrojového kódu nebo nìjaké
knihovny), pro jejich vytváøení je tøeba vlastnit licenci na archivátor, která
svou cenou èasto pøesahuje cenu celého Salamandera. Salamander proto dokáe
vyhledat externí archivátory na disku uivatele a bìhem pakování je zavolat. 
ádnı externí archivátor však není souèástí distribuce Salamandera.

Salamander ve verzi 1.6 beta 4 (èerven 2000) obsahoval první implementaci pluginù
ve formì, jak jí známe dnes. Zdrojovı kód jádra se implementací pluginového
rozhraní  zvìtšil o 1 MB. V tuto dobu jsme vyvinuli první plugin typu archivátor: 
náš vlastní ZIP. Z InfoZIPu pøebírá pouze algoritmy (jako Inflate a Deflate),
vše ostatní je naprogramováno znovu. 

Pokud v následujícím textu budeme zmiòovat archivátor, máme na mysli plugin
typu archivátor, tedy plugin umoòující procházení a vybalování archivù, pøípadnì
jejich vytváøení. Pojmem externí archivátor se rozumí samostatnı pakovaè 
(jako je ARJ.EXE), kterı není souèástí distribuce Salamandera, ale Salamander
ho dokáe spouštìt, tedy zná jeho specifické switche, listingy a návratové kódy.

Pluginy typu archivátor (archivátory) vznikaly postupnì:
  1.6 beta 4:  ZIP, TAR
  1.6 beta 6:  PAK, UnACE, UnARJ a UnRAR 
  (finální verze 1.6 nikdy nevznikla, byla pøejmenvána na verzi 2.0)
  2.0:         UnCAB 
  2.5 beta 1:  UnLHA a UnMIME
  2.5 beta 3:  Encrypt a UnISO
  2.5 beta 4:  UnFAT

Jak postupoval vıvoj Salamandera, rozšiøovalo se jeho rozhraní pro pluginy a
zároveò se mìnil obraz ideální implementace archivátoru. Tyto zmìny umonily
pøesunutí nìkterıch opakujících se èástí kódu z pluginù do jádra Salamandera
a odstranìní zbyteènıch redundancí. Zároveò se zvıšila volnost v drení a 
pøedávání dat mezi Salamanderem a archivátorem.

Ke zmìnám v rozhraní Salamandera nedocházelo samovolnì. Nìkteré zmìny si vyádala
implementace novıch funkcí na stranì Salamandera. Jiné zmìny byly provedeny pøi
vzniku novıch archivátorù pro specifické potøeby jejich autorù. Staré pluginy
vìtšinou nereflektovaly tyto zmìny a nyní pouívají pøekonané nebo neefektivní
techniky.

Bìhem testování novıch archivátorù naráíme na opakující se skupiny problémù
a chyb. Jak roste poèet archivátorù, pøestává pro nás bıt únosné peèlivì 
otestovat všechny nástrahy a kadému z autorù je vysvìtlovat jednotlivì. 
Proto mimo jiné vzniká tento dokument, kterı má potenciální problémy zdokumentovat
a navrhnout jejich øešení. Autoøi archivátorù tak budou schopni své projekty
lépe ošetøit a protestovat.


2. Budoucnost archivátorù
=========================
Rozhraní pro archivátory zatím nedozrálo do finálního stavu a èeká nás
ještì nìkolik jeho obrození. K nejádanìjším a plánovanım funkcím patøí:
 -práce s archivy na pozadí (jako u základních operací Salamandera copy/move/del...)
 -podpora pro zanoøené archivy (nested archives)
 -hledání v archivech (také ve vnoøenıch archivech), hledání v obsahu
 -monost vstupu do SFX/neasociovaného archivu pomocí Ctrl+PgDn
 -pøejmenování souboru a adresáøe pøímo v archivu
 -monost oznaèit v panelu vìtší mnoství archivù a vybalit je jedním pøíkazem
 -implementace metod Inflate a Deflate na úrovni jádra Salamandera a vyvezení
  jejich rozhraní, abychom pøedešli redundanci kódu v pluginech
 -zobrazování compress ratio ve zvláštním sloupci v panelu
 -komprimace souborù a adresáøù nalezenıch Find dialogem
 -podpoøení dalších formatù, jako je CHM (kompilát HTML souborù slouící jako
  helpy ve Windows), DBX (Outlook Express archiv), DEB (distribuèní balíky Debian)
  a jiste pøijdou další kandidáti
 -porovnání archivu a adresáøe na disku také podle obsahu souborù

Nìkteré funkce budeme snad schopni implementovat bez zásahu do rozhraní (jako
nedávno pøidanou podporu pro drag&drop), ale nìkteré budou znamenat úpravy na
stranì archivátorù. Nezbytná budoucí údrba archivátorù je dalším dùvodem k napsání
tohoto dokumentu. Pokud máme provádìt zmìny nad dvaceti archivátory, pak a jsou
si jejich zdrojové kódy a jejich chování pokud mono co nejpodobnìjší.


3. Hlavní a vedlejší funkce archivátorù
=======================================
Plugin typu archivátor primárnì slouí k vytváøení, procházení a rozbalování
archivù. Archiv je soubor (nebo mnoina souborù), kterı obsahuje kompilaci 
souborù a adresáøù, vìtšinou ve stromové hierarchii. Archivy mají rùzné
úèely, nejèastìji se jedná o komprimaci a archivaci souborù. Za archiv
lze povaovat i image CD nebo diskety, stejne jako email s pøílohou ve
formatu EML.

Archivátory dìlíme podle nabízenıch funkcí na packery a unpackery. Unpackery
umìjí pouze procházet a vybalovat obsah archivu (pouíváme pro to pojmy expand,
unpack, extract, explode, rozbalení, extrakce atd.) a jejich název má prefix 
Un (UnARJ, UnCAB, ...). Pluginy ZIP, PAK, Encrypt a 7-Zip umìjí navíc archivy
vytváøet a omezenì modifikovat (packery). Omezenou modifikací archivu myslíme
pøidávání souborù a adresáøu do existujícího archivu a mazání souborù a
adresáøù z archivu. Pøi instalaci plugin Salamanderu sdìlí, které skupiny
funkcí podporuje.

Jeden plugin typu archivátor je èasto asociován s vìtším mnostvím formátù. 
Dobrım pøíkladem je právì TAR, kterı dokáe rozbalit formáty TAR, TGZ, GZ,
TBZ, BZ, BZ2, RPM, CPIO, TAZ a Z. Snaíme se sdruovat tématicky podobné
formáty pod jeden plugin z dùvodu spoleèného enginu pro pøístup k datùm,
pøípadnì pro logickou pøíbuznost formátù.

Archivátory mají monost pøidat nové sloupce do panelu a zobrazit tak napøíklad
Packed Size nebo Method (viz plugin 7-Zip).

Nìkteré archivátory jsou zároveò registrované jako viewery a dokáí zobrazit
informace o archivu, které nám obyèejnı listing v panelu nedovolí prezentovat.
Napøíklad UnISO plugin dokáe zobrazit poèet sessions a trackù obsaenıch
v obrazu CD.

Pokud je archiv otevøen v panelu, umoòuje Salamander porovnat jeho obsah
s adresáøem na disku (Compare Directories). Zatím není podporováno porovnání
podle obsahu, které bude muset jednotlivé soubory vybalovat. 

Archivátory mohou pøidat své pøíkazy do menu Plugins a zpøístupnit tak nìkteré
speciální funkce. ZIP plugin nabízí monost zobrazit a zmìnit komentáø
ZIPu, pøípadnì otestovat jeho integritu. 


4. Krátkı úvod do pluginù
=========================
Pluginy slouí k rozšiøování funkcionality Salamandera. K jejich implementaci
jsme pøistoupili po nìkolikatıdenní diskuzi. Jejich pùvodní návrh zamıšlel
pluginy minimálnì o øád mocnìjší a obecnìjší, ne je jejich souèasná implementace.
K tomu naštìstí nedošlo, byl by to s urèitostí konec Salamandera. I podpora
pro souèasnou zjednodušenou formu pluginù na stranì Salamandera nas stála pøes
rok práce a programování pluginù typu file system rozhodnì není procházkou
rùovım sadem.

Pøes všechna úskalí a problémy povaujeme zvolenou pluginovou architekturu
za krok správnım smìrem. Dùvody shrnu v krátkıch bodech.

Vıhody modulární architektury proti monolitické aplikaci:
-S rostoucím mnostvím implementovanıch funkcí se aplikace stávají ménì
 pøehledné a pøijatelné pro nové uivatele. Modulární architektura umoòuje
 nainstalovat pouze pluginy, potamu pøíkazy, které uivatel potøebuje.
 Lze pøipravit nìkolik verzí instalace (Lite/Standard/Full).
-Pluginy lze zavádìt do pamìti a v okamiku potøeby. Tím se zkracuje
 startovací èas aplikace a zmenšují se její pamìové nároky.
-Díky pluginùm jsme schopni uøídit jejich autory pøi implementaci novıch
 funkcí Salamandera. V dnešní dobì leí vìtšina zdrojového kódu právì
 v pluginech. Jádro se od verze 1.0 stále vyvíjí a rozšiøuje, nikdy
 nebylo pøepsáno. Zanesení zmìn do nìj se stáva èernou magií, kdy si
 na urèitou triviální zmìnu udìláme tøikrát víc èasu, vìtšinou neprohloupíme.
-Díky SDK mají další subjekty monost implementovat vlastní pluginy, tøeba i pro
 vnitøní potøebu (ádané jsou zejména archivátory pro proprietární datové formáty)
-Pluginy lze snadno upgradovat formou malého instalaèního balíèku.
-Do komerèní close-source aplikace lze pøi vhodnì zvolené licenci (LGPL)
 zaèlenit open-source moduly.
-Je tu slušná šance na vznik programátorské komunity, která naimplementuje
 pluginy, které nebudou v našich silách. Samozøejmì je pak otázkou jejich
 kvalita. Tento model se silnì projevil u Total Commandera a FARa.

Nevıhody modulární architektury:
-Do jádra Salamandera bylo tøeba implementovat rozhraní pro pluginy.
-Vznikají redundance v kódu pluginù, napøíklad Inflate/Deflate algoritmus
 je dnes minimálnì na pìti místech.
-Pokud rozhraní Salamandera nepublikuje urèitou funkci, plugin ji nemá dostupnou.
-Monolitické aplikace jsou lépe pøijímány uivatelem: pokud si mùe na
 disketu nakopírovat jedno EXE a jeden INI soubor, je uivatel štastnı.
 Ze sloité stromové struktury se mu obrací aludek.

Plugin Salamandera je DLL knihovna, která exportuje dva entry pointy:
SalamanderPluginEntry a SalamanderPluginGetReqVer. SalamanderPluginEntry slouí
k navázání komunikace mezi jádrem Salamandera a pluginem. Druhı export slouí 
k ovìøení vzájemné kompatibility urèité verze pluginu a Salamandera.

Pluginy jsou standardnì umístìny v adresáøi plugins pod domovskım adresáøem
Salamandera. Kadı plugin má svùj podadresáø. V nìm je umístìn vlastní plugin
s pøíponou SPL (Salamander PLugin). Pluginy mùou bıt i v jakémkoliv jiném
adresáøi, co se hodí napø. pøi jejich vıvoji.

Konfigurace pluginu je uloena v Registry jako podstrom konfigurace Salamandera
a plugin k ní pøistupuje prostøednictvím vyhrazeného rozhraní. Z uivatelského
hlediska je konfigurace pluginù oddìlena od konfiguraèního okna Salamandera
(Options / Configuration). Konfiguraèní okna pluginù lze otevøít z menu
Options / Plugin Configuration, pøípadnì z okna Plugins Manager. Samozøejmì
nás lákala myšlenka integrovat konfiguraci pluginù jako jednu ze stránek 
konfigurace Salamandera, ale po zralé úvaze jsme tuto variantu opustili.
Pøineslo by to obrovské mnoství komplikací.

Rozlišujeme nìkolik základních skupin pluginù podle funkcí, které nabízejí.
Skupiny se dle potøeby v pluginech rùznì prolínají. Jsou to:
-viewery
-archivátory (packery a unpackery)
-file systémy (WinSCP, FTP, Registry Editor, Windows Mobile)
-rozšíøení menu (File Comparator, Check for new version, Split & Combine, ...)
-naèítaèe thumbnailù (PictView, Eroiica)

Viewery, archivátory a file systémy mají své chování v rámci Salamandera 
pevnì dáno. Viewery se aktivují pøíkazem View (F3), archivátory pøíkazem
Pack (Alt+F5), Unpack (Alt+F9) nebo pøi otevøení archivu v panelu (Enter
na archivu). File systémy se aktivují z Change Drive menu (Alt+F1/2).
Pluginy rozšiøující menu mají své pøíkazy v menu Plugins, kde mají svá
submenu. Pluginy naèítaèù thumbnailù se registrují pro skupinu masek
souborù a Salamander je pak pro tyto soubory postupnì volá (panel v reimu
Thumbnails).


5. Instalace archivátorù do Salamandera
=======================================
Archivátory se z hlediska instalace nièím neliší od ostatních pluginù.

Existují tøi cesty, jak se Salamander dozví o existenci pluginu. První
cestou je nová instalace Salamandera, kdy Salamander prochazí adresáø plugins
ve svém domovského adresáøi a snaí se všechny soubory s pøíponou .SPL pøidat
mezi pluginy.

Druhá cesta je variantou té první a pouíváme jí pøi samostatné distribuci
novıch nebo aktualizovanıch pluginù. Uivatel si z www stránek stáhne instalaèní
balíèek (.EXE), kterı ho pøed instalací vyzve k ukonèení Salamandera. Následnì
umístí plugin do adresáøe plugins a modifikuje textovı soubor plugins\plugins.ver
tak, aby po novém spuštìní Salamandera došlo k automatickému pøidání pluginu.

Tøetí cesta vede pøes ruèní správu pluginù. V menu Plugins je pøíkaz Plugins
Manager, kterı otevøe okno urèené k prohlíení, pøidávání, odebírání a konfiguraci
pluginù. 

Konfigurace Salamandera je uloena v Registry. Kadá verze Salamandera
(vèetnì beta verzí) má svùj vlastní nezávislı klíè. Napøíklad
REG:\HKEY_CURRENT_USER\Software\Altap\Altap Salamander 2.5
Bìhem instalace nové verze Salamandera má uivatel monost importovant nìkterou
ze starších verzí konfigurace. Dùvodem je komfort uivatele, kterı nemusí
s instalací kadé nové verze znovu procházet všechny volby konfigurace.

Schopnost naèíst všechny staré verze konfigurace a konvertovat je na konfiguraci
novou tak padá také na pluginy. Otázkám konfiguraèních záznamù pluginù a jejich
konverzi se budeme vìnovat ve zvláštní kapitole.


6. Jak vidí archivátory uivatel Salamandera
============================================
Z pohledu uivatele existují dva rozdílné pøístupy k rozbalování archivu (pøípadnì
pakování do nìj).

Jeden pøístup je interaktivní. Uivatel vyhledá archiv a klávesou Enter do nìj
vstoupí. Obsah archivu se zobrazí v panelu. Uivatel mùe pøíkazem View prohlíet
obsah souborù, klávesou Space seèíst velikost souborù a na závìr napøíklad
nìkteré soubory oznaèit a pøekopírovat je pøíkazem Copy do protìjšího panelu.
Archivátor mùe v tomto interaktivním reimu nabízet pouze read-only pøístup,
tedy procházení (listování) archivu nebo mùe podporovat také zmìnu archivu (editaci).
V tomto pøípadì lze do archivu nakopírovat soubory a adresáøe, pøípadnì existující
oznaèit a smazat. Bìhem interaktivní práce s archivem lze pouít i drag&drop pro
operace se soubory a adresáøi. Další moností je pøíkaz Edit, kterı umonuje
editovat zvolenı soubor asociovanım editorem a následnì zmìnìnı soubor zabalit
zpìt do archivu. Interaktivní pøístup má za cíl uivatele maximálnì odstínit
od faktu, e pracuje s archivem. Salamander se chová, jako by se jednalo o virtuální
adresáø obsahující soubory a adresáøe.

Druhı pøístup je neinteraktivní. Uivatel nemusí pøed vybalováním chtít prohlíet
obsah archivu, nebo èastìji chce oznaèené soubory na disku zabalit do nového archivu.
Pro tento neinteraktivní pøístup slouí pøíkazy Pack (Alt+F5) a Unpack (Alt+F9).
Uivatel oznaèí soubory na disku a zavolá pøíkaz Pack. Následuje dialog, kde
si zvolí název cílového archivu (combobox automaticky nabízí alternativní umístìní)
a vybere jeden z nabízenıch packerù. Navíc lze zabalené soubory nechat smazat z disku.
Rozbalování probíhá obdobnım zpùsobem. Uivatel vyhledá archiv a pøíkazem Unpack otevøe
dialog. V nìm má monost nastavit cílovou cestu pro vybalované soubory, zvolit unpacker
(podle pøípony se jeden nabídne automaticky). Navíc lze rozbalování omezit pouze na
soubory zadané maskou.

Obecné chování archivátorù má uivatel monost ovlivnit v konfiguraci Salamandera
(Options / Configuration / Archivers)

Stránka Archivers obsahuje ètyøi volby. Use simple icons in archives se vztahuje
k interaktivnímu pøístupu, kdy je obsah archivu zobrazen v panelu. Ostatní tøi volby
se tıkají pøíkazù Pack a Unpack.

Stránka Archives Associations in Panels slouí k asociaci archivátoru pro
interaktivní reim, tedy otevøení archivu v panelu. Seznam obsahuje na
kadém øádku jednu nebo více extended masek. Extended masky mají zvláštní
syntaxi a znak # v nich odpovídá libovolné èíslici. Ke kadému øádku je
pøiøazen archivátor (plugin nebo externí) pro read-only operace jako je
listování a rozpakování a zvláš pro edit operace, jako je zapakování a
mazání z archivu. Pokud uivatel smae asociaci napøíklad pro RAR, bude
se na Enter na .RAR archivu spouštìt pøíslušná aplikace asociovaná ve
Windows. Zároveò mùe zùstat zachována monost vytváøet a rozbalovat RAR
archivy pomocí neinteraktivního pøístupu, tedy pøíkazù Pack a Unpack.
Soubory s pøíponou odpovídající nìkteré z masek na této stránce budou
v panelu zobrazeny se speciální ikonkou archivu.

Stránka External Archivers Locations slouí k nastavení cest k jednotlivım
externím archivátorùm.

Stránky Packers in Pack dialog box a Unpackers in Unpack Dialog box slouí
ke konfiguraci archivátorù v neinteraktivním reimu.

Chování jednotlivıch archivátorù lze èasto ovlivnit v jejich pluginové konfiguraci
(Options / Plugins Configuration / název_pluginu).

Dalším místem, kde uivatel pøijde do styku s archivátory je Plugins / Plugin Manager.
Po vybrání konkrétního archivátoru budou zobrazeny podporované pøípony a funkce.


7. Rozdíly mezi archivátory a pluginy typu file systém
======================================================
Pluginem typu file systém (FS) rozumíme pluginy jako jsou FTP klient, WinSCP/SFTP,
Registry Editor, Windows Mobile. Jejich úloha spoèíva v prezentovaní poloek
a adresáøù v panelu Salamandera. Poloky mohou odpovídat souborùm (FTP) nebo
se mùe jednat o hodnoty v Registry. ádanı je napøíklad FS plugin, kterı by
v panelu zobrazil seznam procesù ve stylu Správce úloh pod Windows.

FS pluginy nemají neinteraktivní pøístup jako archivátory pøes pøíkazy Pack a Unpack.

Vıznamnı rozdíl mezi archivátory a FS leí pod povrchem a z pohledu uivatele není
zøejmı. Salamander po archivátorech bìhem otevírání archivu v panelu vyaduje
enumeraci celého listingu archivu, vèetnì všech podadresáøù. Takto získanı listing
si drí Salamander ve vlastních datovıch strukturách. Jak uivatel prohlíí obsah
archivu a prochází jeho adresáøi, Salamander u nevolá archivátor a vše prezentuje
z vlastních dat. Stejná data vyuije v pøípadì, e uivatel porovnává archiv s
diskem pøíkazem Compare Directories (Ctrl+F10) nebo v pøípadì vıpoètu velikosti
souborù pøes podadresáøe (Calculate Directories Sizes).

FS pluginy naopak poskytují jen listingy aktuálních cest a to prùbìnì, jak
uivatel mìní cestu v panelu nebo se provádí Refresh obsahu panelu. FS pluginy
by sami mìly získávat listingy prùbìnì, protoe vìtšinou je nutné poèítat
s tím, e je zároveò mohou mìnit tøetí osoby (napø. obsah FTP serveru mìní
zároveò i jiní uivatelé). Pøípadnì z dùvodu rychlostních optimalizací mùe
plugin listingy cest ukládat do vlastní cache a vracet je pøímo z této cache,
pak pøirozenì hrozí neaktuálnost cachovaného listingu.

FS pluginy jsou implementaènì øádovì komplikovanìjší ne pluginy typu
archivátor. Je to dáno volností, kterou FS plugin má. Díky této volnosti
se však Salamander stává pouze jakımsi terminálem pluginu, jeho displejem
a klávesnicí. Veškeré sluby a logika musí bıt implementována na úrovni
pluginu. Tomu odpovídá komplikované rozhraní pro FS pluginy proti rozhraní
pro archivátory, které má jen asi deset metod.

Díky jednoduchému rozhraní pro archivátory a jasnì vymezenım pravidlùm,
jak mùe vypadat struktura archivu, bylo moné v pøípadì pluginù typu archivátor
pøesunout mnoho funkcí do jádra Salamandera. Jedná se o tyto funkce:
-pøíkaz View
 Jádro si nechá vybalit zvolenı soubor do doèasného adresáøe a následnì
 zavolá klasickı pøíkaz View. Doèasnı adresáø slouí jako cache a opakovanı
 pøíkaz View pro stejnı soubor u nevyvolá rozpakování z archivu.
-pøíkaz Edit
 Jádro opìt vybalí soubor do doèasného adresáøe, a spustí asociovanı editor.
 Ve chvíli, kdy se uivatel pokusí opustit archiv, Salamander vybídne k
 uloení editovaného souboru a nabídne jeho zabalení zpìt do archivu.
 Malá odboèka: protoe nejsme schopni rozpoznat, kdy editace skonèila (nemusí
 jít vdy o ukonèení procesu editoru), museli jsme nabídku zpìtné komprimace
 pøesunout právì na opouštìní archivu.
-automatickı Refresh
 Bìhem prohlíení archivu Salamander hlídá zmìny a pokud dojde k aktualizaci
 archivu, je automaticky znovu vylistován a obnoven obsah panelu.
-pøíkazy pro vıpoèet velikostí souborù
 Space, Calculate Occupied Space, Calculate Directory Sizes
 Tyto pøíkazy øeší kompletnì jádro a archivátor bìhem nich není volán.
-pøíkaz Compare Directories
 Díky tomu, e po otevøení archivu v panelu zná Salamander jeho kompletní
 strukturu, nebylo problematické implementovat porovnání archivu a adresáøe
 na disku nebo dokonce dvou archivù mezi sebou.
-navigace v archivu
 Nad panelem je zobrazena takzvaná Directory Line, která zobrazuje aktuální
 cestu v archivu. Uivatel mùe myší pøeskoèit do libovolného nadøazeného
 adresáøe tím, e na nìj ukáe a klikne. Tato funkce byla velice dobøe pøijata
 uivateli. Opìt stojí na faktu, e Salamander zná obsah prohlíeného archivu.
 V pøípadì FS pluginu je její implementace sloitìjší, protoe plugin musí
 jádru øíct, co jsou jednotlivé sloky cesty. Cesta je tam Salamanderem chápána
 jako øetìzec, nikoliv jako stromová struktura a je na FS pluginu, aby identifikoval
 co jsou jednotlivé adresáøe.


8. Vrstvená architektura archivátoru a jejich engine
====================================================
Kadı archivátor má minimálnì dvì vrstvy. Jedna vrstva zodpovídá za komunikaci
s jádrem Salamandera a implementuje pluginovou èást rozhraní. Tato vrstva je témìø
shodná pro všechny archivátory. Liší se sadou metod, kterou implementuje (podle
toho, zda je archivátor unpacker nebo i packer).

Druhá vrstva je to, co dìlá archivátor unikátním. Jedná se o vlastní engine,
kterı dokáe otevøít archiv (na úrovni souboru), naèíst jeho strukturu a nakrmit
jádro Salamandera daty. V pøípadì packerù je tento engine zodpovìdnı také
za modifikaci archivù, tedy zápis do nich.

Engine mùe pouívat dùmyslné pakovací algoritmy nebo se mùe jednat o triviální
zmìnu kódování znaku, jako je tomu v pøípadì pluginu UnMIME.

Existuje nìkolik forem jak pøipojit engine k archivátoru:
-zdrojovı kód enginu
-statická knihovna .LIB
-dynamická knihovna .DLL
-jiná forma (napøíklad volání OLE)

Záleí na povaze formátu archivu, pro kterou z moností se rozhodneme.
Mnoho formátù je proprietárních a neexistují od nich specifikace. Klasickım
zástupcem je RAR nebo Microsoft CAB. V takovém pøípadì se spoléháme na
knihovnu dodávanou majitelem formátu. V pøípadì RARu je to dynamická
knihovna unrar.dll a v pøípade MS CABu staticky linkovaná knihovna z
MS CAB SDK. Licence pro tyto knihovny bıvají èasto zcela neomezené, protoe
se autoøi formátù snaí ukousnout co nejvìtší podíl trhu. Vìtšinou se
jedná pouze o rozbalovací èásti algoritmù.

Engine na úrovni zdrojovıch kódù lze nejlépe integrovat do archivátoru.
Máme plnì v rukách alokace pamìti, zobrazování chybovıch hlášek, pøístup
ke všem datùm z archivu atd. Pokud však formát archivu není dostateènì
zakonzervovanı a co pùl rok pøicházejí jeho nové verze, mùe se tento
pøístup snadno stát noèní mùrou. V takovém pøípadì se snaíme zvolit
spíš mìnì prunou DLL nebo LIB knihovnu, kde máme jistotu, e autoøi
vydají nové verze reflektující zmìny ve formátu archivu.


9. ivotní cyklus pluginu
=========================

Postup naèítání (pøipojování) pluginu do Salamandera:
  - naètení .SPL modulu pluginu
  - volání funkce SalamanderPluginGetReqVer: ukonèení naèítání pokud plugin není
    postaven pro verzi Salamandera kompatibilní s právì spuštìnım Salamanderem
  - volání SalamanderPluginEntry: ukonèení naèítání pokud není v .SPL modulu taková
    funkce (export) nebo pokud nevolá SetBasicPluginData nebo pokud vrátí NULL
    (nevrátí rozhraní pluginu, viz CPluginInterface v DemoPlug pluginu)
  - volání metody LoadConfiguration získaného rozhraní pluginu: pokud plugin podporuje
    "load/save configuration" (viz FUNCTION_LOADSAVECONFIGURATION) naète konfiguraci
    z pøidìleného soukromého klíèe z registry nebo pouije defaultní hodnoty (pokud
    "load/save configuration" nepodporuje)
  - volání metody Connect získaného rozhraní pluginu

Postup odpojení pluginu:
  - pokud plugin podporuje "load/save configuration" volá se metoda SaveConfiguration
    získaného rozhraní pluginu
  - volání metody Release získaného rozhraní pluginu: vrátí-li FALSE dostane uivatel
    monost donutit plugin k odpojení (další volání Release s parametrem force=TRUE)
    (ukonèení odpojování pokud uivatel nechce nutit plugin k odpojení)
  - uvolnìní (unload) .SPL modulu pluginu


10. Úvod do implementace archivátoru
====================================
Jako zdroj informací a základ pro novı plugin archivátoru poslouí
demonstraèní plugin DemoPlug. Pokud byste mìli pocit, e by vám lépe
poslouily zdrojové kódy jiného pluginu archivátoru, zkuste nás
kontaktovat.

Salamander se snaí co moná nejdéle pluginy nenaèítat do pamìti. Motivací je
rychlejší start aplikace a zároveò niší pamìové nároky. Pro ilustraci napø.
ve verzi Salamander 2.5 STANDARD (verze neobsahující velké pluginy Eroiica a
WinSCP) je rozdìlení velikostí naèítanıch modulù 1,9MB (jádro) ku 4,2MB
(pluginy).

Salamander tedy musí o kadém pluginu dret základní informace ve své vlastní
konfiguraci. Jde hlavnì o jméno pluginu, umístìní modulu pluginu (.SPL),
podporované funkce (archivátor, FS, viewer, atd.) a poloky pøidávané do menu
(vèetnì ikon). Dále Salamander drí v konfiguraci kde a jak se pouívají
pluginové funkce. Napø. v prioritním seznamu masek pro viewery (viz konfiguraèní
stránka Viewers) je uvedené pro jaké masky se má pouívat viewer pluginu,
podobnì je uloené pro jaké pøípony se pouívá archivátor pluginu, atd.

Všechna tato data o pluginech se získají pøi prvním naètení pluginu (instalaci)
do Salamandera a pøi dalších naèteních pluginu je moné tato data upravovat
(viz metoda CPluginInterfaceAbstract::Connect). Úprava je citlivá záleitost,
protoe jde o data, která mùe mìnit i uivatel a plugin by tedy nemìl uivatele
o jeho zmìny pøipravit. Napø. uivatel si promae (nebo doplní) seznam pøípon
pro viewer z pluginu nebo promae pøípony archivù, které si pøeje zpracovávat
jinou aplikací (napø. WinRARem).

V SalamanderPluginEntry pøi volání SetBasicPluginData plugin urèí,
které skupiny funkcí bude podporovat. Nejèastìji to bude kombinace
FUNCTION_PANELARCHIVERVIEW a FUNCTION_CUSTOMARCHIVERUNPACK pro unpackery.
V pøípadì packerù doplnìné o FUNCTION_PANELARCHIVEREDIT a
FUNCTION_CUSTOMARCHIVERPACK. Konstanty FUNCTION_PANELARCHIVER(VIEW a
EDIT) patøí interaktivnímu pøístupu (tedy otevøení archivu v panelu),
zatímco konstanty FUNCTION_CUSTOMARCHIVER(PACK a UNPACK) náleí
neinteraktivnímu pøístupu (tedy zastoupení pluginu v pøíkazech Pack
a Unpack).

Dalším dùleitım krokem je implementace potomka rozhraní
CPluginInterfaceForArchiverAbstract. Potomka pojmenujme napøíklad
CPluginInterfaceForArchiver.

Unpacker implementuje jeho metody ListArchive, UnpackArchive, UnpackOneFile a 
UnpackWholeArchive. Ostatní metody rozhraní budou pouze vracet návratovou hodnotu.
Metody ListArchive, UnpackArchive, UnpackOneFile patøí ke konstantì
FUNCTION_PANELARCHIVERVIEW a jsou nezbytné pro interaktivní reim.
Metoda UnpackWholeArchive patøí ke konstantì FUNCTION_CUSTOMARCHIVERUNPACK
a bude slouit pro reim neinteraktivní, tedy bude volána z pøíkazu Unpack.

Packer musí implementovat navíc metody PackToArchive a DeleteFromArchive pro
interaktivní reim, pøípadnì PackToArchiv pro neinteraktivní reim.
PackToArchive je sdílená obìma pøístupy.


11. Drení listingu archivu: kontext
====================================
V oblasti drení listingu došlo bìhem vıvoje Salamandera k nejvìtším zmìnám.
Staré verze rozhraní CPluginInterfaceForArchiverAbstract neumonovaly pluginu
elegantnì udrovat kontext bìhem volání interaktivních (panelovıch) metod
ListArchive, UnpackArchive, UnpackOneFile, PackToArchive a DeleteFromArchive.
To je historickı dùvod, proè do všech metod vstupuje cesta k archivu.

Pod tlakem autorù archivátorù postupnì dostaly tyto metody parametr
CPluginDataInterfaceAbstract *pluginData, kterı lze (mimo jiné) pouít
právì pro drení kontextu.

Starı bezkontextovı pøístup je stále podporovanı a autor archivátoru se
mùe rozhodnout, zda kontext vyuije.

Kontextem rozumíme nìjakı objekt, kterı drí informace potøebné bìhem
pøítomnosti archivu v panelu, tedy pøi interaktivním pøístupu. Pozdìji
si ukáeme, jak lze kontext vyuít v pøípadì neinteraktivního pøíkazu
Unpack. Kontext mùe napøíklad obsahovat heslo k šifrovanım souborùm
archivu nebo informace vyètené z hlavièky archivu bìhem jeho otevírání.

Kontext vzniká bìhem volání metody ListArchive, vyuije se v metodách
UnpackArchive, UnpackOneFile, PackToArchive a DeleteFromArchive. Kontext
zaniká, kdy uivatel mìní cestu v panelu z archivu ven. Tehdy jádro
Salamandera zavolá CPluginInterfaceAbstract::ReleasePluginDataInterface.
Existuje jedna vıjimka, kdy ReleasePluginDataInterface není zavoláno pøi
opuštìní archivu. Ta nastane pokud uivatel nakopíroval nìkteré soubory
nebo adresáøe do schránky (Ctrl+C) a Salamander pak odloí uvolnìní dat
na pøíkaz Paste.

POZOR: nepouívat CPluginInterfaceForArchiverAbstract::CanCloseArchive 
pro rušení kontextu. I v pøípadì, e z metody CanCloseArchive vrátíme
TRUE, archiv mùe zùstat otevøenı v panelu, protoe se nemusí podaøit
vylistovat novou cestu.

Jak pracovat s kontextem:
1) Pøi otevírání archivu v panelu jádro Salamandera volá metodu pluginu
   ListArchive. Ta je zodpovìdná za kompletní enumeraci archivu a pøedání
   takto získaného listingu jádru Salamandera prostøednictvím parametru 
   CSalamanderDirectoryAbstract *dir. 
   
   Vytvoøíme objekt-kontext, v pøípadì pluginu UnFAT pùjde o instanci
   tøídy CFATImage, která zapouzdøuje práci s FAT 12, 16 a 32 obrazem.

   Ukazatel na kontext uloíme do potomka rozhraní CPluginDataInterfaceAbstract,
   kterého pojmenujme napøíklad CPluginDataInterface. Zatím se nebudeme
   zabıvat implementací metod tohoto rozhraní a pouze vrátíme návratovou
   hodnotu ve smyslu OK.
   
   class CPluginDataInterface: public CPluginDataInterfaceAbstract
   {
     protected:
       CFATImage *FATImage; // ukazatel na kontext
 
     public:
       CPluginDataInterface(CFATImage *fatImage)
       {
         FATImage = fatImage;
       }
       
       ~CPluginDataInterface()
       {
         if (FATImage != NULL)
         {
           delete (FATImage);
           FATImage = NULL;
         }
       }

       .... // prazdna implementace metod CPluginDataInterfaceAbstract
 
       CFATImage *GetFATImage() {return FATImage;}
   };
   
   V metodì ListArchive alokujeme instanci objektu CPluginDataInterface
   a vrátíme jí pøes parametr CPluginDataInterfaceAbstract *&pluginData
   jádru Salamandera:
   
   CFATImage *img = new CFATImage();           // alokujeme kontext
   pluginData = new CPluginDataInterface(img); // schovame si ho do pluginData
   img->Open(fileName);                        // nechame kontext otevrit archiv
   img->ListImage(dir);                        // pozadame o listing archivu
   return TRUE;                                // a nezapomene osetrit vsechny chybove stavy ;-)
    
2) Pokud jádro Salamandera nyní zavolá kteroukoliv z metod interaktivních (panelovıch)
   metod UnpackArchive, UnpackOneFile, PackToArchive nebo DeleteFromArchive, pøedá v
   parametru 'pluginData' ukazatel na náš alokovanı objekt, v kterém máme uloen ukazatel
   na kontext.
   
   Pro vytaení ukazatele je tøeba pøetypování ukazatele z CPluginDataInterfaceAbstract: 
   CFATImage *img = ((CPluginDataInterface*)pluginData)->GetFATImage();

3) V okamiku kdy uivatel opustí archiv (zmìnou cesty v panelu) zavolá Salamander metodu
   pluginu, ve které provedeme destrukci kontextu.

   void 
   CPluginInterface::ReleasePluginDataInterface(CPluginDataInterfaceAbstract *pluginData)
   {
     delete ((CPluginDataInterface *)pluginData);
   }

Kontext lze pouít také v neinteraktivním pøístupu, tedy pøi implementaci metody UnpackWholeArchive:

  CPluginInterfaceForArchiver::UnpackWholeArchive(CSalamanderForOperationsAbstract *salamander, 
                                                  const char *fileName, const char *mask,
                                                  const char *targetDir, BOOL delArchiveWhenDone,
                                                  CDynamicString *archiveVolumes)
  {
    // do teto docasne promenne nechame naplnit obsah archivu
    CSalamanderDirectoryAbstract *dir = SalamanderGeneral->AllocSalamanderDirectory(FALSE);

    // drzak ukazatele na kontext
    CPluginDataInterfaceAbstract *pluginData = NULL;
    if (ListArchive(salamander, fileName, dir, pluginData))
    {
      // v 'dir' mame vsechny polozky archivu a muzeme provest extrakci...
    
      // na zaver po sobe uklidime
      PluginInterface.ReleasePluginDataInterface(pluginData);
    }
    SalamanderGeneral->FreeSalamanderDirectory(dir);
  }

O promìnné CFileData::PluginData
Metoda CFATImage::ListImage, která je zodpovìdná za enumeraci poloek archivu,
pouije svùj parametr CSalamanderDirectoryAbstract *dir k pøedání listing jádru
Salamandera. Slouí k tomu metody CSalamanderDirectoryAbstract::AddFile
a ::AddDir. Informace o souborech a adresáøích se do tìchto metod pøedávají
pomocí struktury CFileData. Zajímavá je její promìnná CFileData::PluginData,
kterou plugin mùe vyuít pro uloení svıch 'custom dat' k jednotlivım souborùm
a adresáøùm. Promìnná existuje vıhradnì pro potøeby pluginu a jádro Salamandera
nijak nerozumí jejímu obsahu.

Promìnná CFileData::PluginData mùe bıt prostı DWORD napø. s prvním sektorem
souboru ve FAT obrazu nebo se mùe jednat napø. o ukazatel na alokovanı objekt.
V tomto pøípadì byl takovı objekt alokován v metodì ListArchive a je tøeba
jej pøi opouštìní archivu dealokovat. Protoe Salamander nezná vıznam
CFileData::PluginData, zeptá se pluginu prostøednictvím metod
CPluginDataInterfaceAbstract::CallReleaseForFiles a ::CallReleaseForDirs
zda má pro kadı soubor a adresáø zavolat metodu ::ReleasePluginData.
Tím umoní pluginu dealokovat CFileData::PluginData.

Popsané pøístupy se z pohledu archivátorù moná jeví ponìkud neohrabanì, co
je dáno jejich souèasnım vyuitím v pluginech typu file system.


12. Optimalizované listování archivu
====================================
Jádro Salamandera obdrí od pluginu listing archivu prostøednictvím metod
CSalamanderDirectoryAbstract::AddFile a ::AddDir volanıch v metodì
ListArchive. Plugin pøedává jádru adresáøe a soubory s plnou cestou. Jádro
Salamandera si je však rozhazuje do stromové struktury, ve které je pak
drí.

Zaøazení pøíchozího souboru nebo adresáøe do interní stromové struktury znamená
rozklad plné cesty a prohledávání stromu. Tento overhead se snaíme minimalizovat
optimalizací, kterou je však tøeba podpoøit na stranì pluginu.

Optimalizace je postavena na cachování poslednì pøidávané plné cesty a jí 
odpovídajícímu místu v interní stromové struktuøe. Cache je implementována
na úrovni metod AddFile a AddDir a z hlediska pluginu je transparentní.

Pokud se má cache uplatnit, musí plugin pøidávat soubory a adresáøe z jednoho
adresáøe v rámci jedné dávky. Adresáøe a soubory mohou bıt v rámci této dávky
na pøeskáèku, dùleité je jen jejich umístìní na stejné cestì.

Optimální pøístup z hlediska cache je tedy pøidání všech souborù a adresáøù
v rámci jedné dávky a teprve následnı sestup do podadresáøù. Pro tyto úèely lze
bìhem pøidávání adresáøù budovat jejich doèasnı seznam, kterı se po rekurzivním
sestupu dealokuje.


13. Vrstva Input/Output
=======================
Vstupnì vıstupní operace se soubory by se mìly v maximální moné míøe
blíit implementaci v jádøe Salamandera. Jedná se pøedevším o ošetøení
chybovıch stavù. Kadá IO operace má tøi fáze: otevøení souboru,
ètení/zápis a na závìr jeho zavøení. Bìhem prvních dvou fází mùe dojít
k celé škále chyb: nedostupná cesta, nedostateèná práva, málo místa
na disku, chyby vımìnnıch médii a další.

Všechny chybové stavy tedy musí bıt detekovány a zobrazeny.

Nabízí se nám nìkolik rodin funkcí, které problematiku ètení a zápisu øeší:
-Memory Mapped Files: CreateFileMapping, MapViewOfFile, UnmapViewOfFile
-Klasické Win32 API: ReadFile, WriteFile
-C Run-Time Library: fread, fwrite
-Jiné, napøíklad COM interface IStream

Pokud jako engine archivátoru pouijeme existující zdrojové kódy, pravdìpodobnì
nebudeme mìnit jejich I/O vrstvu. Pokud však programujeme plugin od základù, je
rozhodnutí na nás. Následuje nìkolik postøehù k jednotlivım pøístupùm.

Memory Mapped Files (MMF)
-------------------------
(+) Umoují mapovat soubor pøímo do adresního prostoru procesu. K souboru se následnì
pøistupuje pouhım ètením nebo zápisem pamìti.

(+) Jeden soubor mùe bıt souèasnì mapován do pamìti více procesù. To je jedinı
rozumnı zpùsob, jak mohou dva procesy pod Windows NT sdílet pamì. Tato technika
se pouívá napøíklad v pøípadì DLL knihoven, kde OS jejich sdílené segmenty zavede
do fyzické pamìti pouze jednou a procesùm je namapuje do jejich adresního prostoru.
To je mimochodem dobrı dùvod, proè bìnì nepouívat in-process kompresory typu UPX.

(+) Pokud aplikace pøistupuje k souboru bajt za bajtem, má pøístup do MMF mnohem
menší overhead ne volání fread nebo ReadFile pro velikost bufferu nìkoli bajtù.

(-) Kadı MMF si ukousne èást systémovıch prostøedkù. Tento argument však nelze
pouít proti MMF, protoe pod Windows NT jsou klasické API ReadFile/WriteFile
øešeny kernelem právì pøes MMF.

(-) Starı argument, e MMF se skvìle hodí pro random pøístup do velkıch souborù
je dnes lichı, protoe soubory nad 4GB jsou zcela bìné a nám nezbıvá ne k nim
pøistupovat mapováním po èástech, stejnì jako pøi klasickém ètení/zápisu.

(-) POZOR, toto je nejvìtší nástraha MMF, kterou se Microsoft neobtìoval v MSDN slušnì
zdokumentovat. Z podstaty MMF nelze ošetøit chybové stavy (napøíklad vadnı sektor na médiu,
pøerušní síové vrstvy) v místì jejich vzniku, tedy pøístupu do mapované pamìti.
Pokud k takové chybì dojde, je generována exception. Pokud ji proces nechytne do
try/except bloku, aplikace spadne.

Jediná zastrèená poznámka v MSDN na toto téma je v Using File Mapping/Reading and Writing:
> Note Reading from or writing to a file view can cause an exception. For example,
> accessing a mapped file that resides on a remote server can generate an exception
> if the connection to the server is lost. Exceptions can also occur because of a full
> disk, because the file is shared and a different process has locked a byte range,
> or because of an underlying device failure or memory allocation failure. To guard
> against exceptions due to input and output (I/O) errors, all attempts to access memory
> mapped files should be wrapped in structured exception handlers.
MSDN zapomíná zmínit, jaké exceptions mohou nastat a co tedy máme chytat.

(*) Asi jste vytušili, e MMF zrovna nemilujeme. Pokud máte nìco na jejich obhajobu,
dejte nám vìdìt.

Win32 API: ReadFile, WriteFile
------------------------------
(+) Jasnì definované a snadno ošetøitelné chybové stavy. Z toho plynoucí monost
zapouzdøit I/O operace do knihovny, která bude øešit Retry/Skip all/Overwrite all
stavy, viz interface CSalamanderSafeFileAbstract.

(+) Pod Windows NT virtuálnì shodnı vıkon s MMF, protoe kernel internì pøevádí 
volání ReadFile a WriteFile právì na MMF.

(-) Pøi ètení/zápisu po malıch segmentech pamìti (do desítek bajtù) vzniká velice
nepøíjemnı overhead ve srovnání s RTL fread/fwrite, kde existuje na úrovni RTL
defaultní 16 KB I/O cache. Tento nedostatek lze øešit ètením po vìtších blocích,
zkrátka cache posunout do aplikace. V ALTAPu se nám tento problém projevil pøi
ètení a zápisu souboru na síovém disku, kde prohloubil overhedem síové vrstvy.
Zavedení malé I/O cache problém odstranilo a rychlost ètení a zápisu se øádovì
zrychlila.

Run-Time Library: fread, fwrite
-------------------------------
(+) Jasnì definované a snadno ošetøitelné chybové stavy.

(+) Zabudovaná cache má dobrı dopad pøi ètení a zápisu po malıch èástech pamìti.

(-) Nekompatibilita s Win32 API. RTL funkce sice internì volají API, ale na venek
mají ANSI C interface. Mají tedy jiné návratové hodnoty, jiné konvence pro
zpracování chybovıch stavù. Navíc nezpøístupòují aplikaci všechny parametry
API funkcí. Nìkteré API nemají v této rodinì funkcí ekvivalenty a jejich zavolání
se stává problémem, protoe nemáme potøebnı handle souboru.

Závìr
-----
Pokud si mùete vybrat, zvolte API funkce ReadFile a WriteFile. Pokud potøebujete
èíst nebo zapisovat po nìkolika bajtech, zaveïte si I/O cache a obejdìte tak
zbyteènı overhead, kterı se mùe drasticky projevit na síovıch discích 
(mùete si to snadno ovìøit experimentem na vaší lokální síti).


14. Ošetøení vstupù a vıstupù: CSalamanderSafeFileAbstract    
==========================================================
Pluginy Salamandera by se komfortem nabízenıch funkcí a robustností jejich zpracování
mìly co nejvíce blíit provedení jádra Salamandera a jeho základních operací, jako
jsou Copy, Move, Delete, Rename atd. V ideální pøípadì by uivatel nemìl pozorovat
ztrátu komfortu pøi pouití funkcí z pluginù proti jejich protìjškùm v jádøe
Salamandera.

V pøípadì archivátorù se jedná pøedevším o ošetøení vstupnì vıstupních operací.
Pokud bìhem otevírání, ètení nebo zápisu souboru dojde k chybì, existují tøi
scénáøe, jak problém øešit:
(1) chybu nezobrazit, ale korektnì zpracovat, tedy vycouvat z operace ven
(2) zobrazit chybu a nabídnout tlaèítko OK, které pøeruší provádìnou operaci
(3) zobrazit chybu a nabídnout tlaèítka jako Retry, Skip, Skip All, Cancel
    (rùzné jejich kombinace viz konstanty BUTTONS_xxx)

Scénáø (1) je vlastnì tichou variantou scénáøe (2) a vyuíváme ho pouze pro
speciální pøípady. Napøíklad archivátor kombinovanı s viewerem, kde je pro
vieweru potøeba implementovat metodu CPluginInterfaceForViewerAbstract::CanViewFile.
Tato metoda se pokusí otevøít, pøípadnì zkusmo vylistovat archiv a pokud nastane
nìjakı problém, tiše vrátí FALSE. 

Scénáø (2) nasazujeme na místech, kde by scénáø (3) nemìl smysl. Pokud napøíklad
uivatel stiskne Enter v panelu, aby vstoupil do archivu (pøípadnì dá pøíkaz Unpack),
je nesmysl zobrazit pod chybové hlášení "Error Opening File"/"(5) Access is denied"
tlaèítka Retry/Cancel. Sem patøí pouze tlaèítko OK, protoe uivatel akci snadno
po odstranìní problému zopakuje. Pod tento scénáø zároveò patøí prohlíení a spouštìní
souborù z archivu. Salamander v tomto pøípadì volá metodu pluginu
CPluginInterfaceForArchiverAbstract::UnpackOneFile.

Scénáø (3) se uplatní všude tam, kde pøerušení operace komplikuje uivatelùm ivot.
Jde napøíklad o pøípad, kdy uivatel vybaluje archiv obsahující stovky souborù
a nìkde uprostøed dojde místo na cílovém disku. Pokud bychom pod chybové hlášení
"Error Writing File"/"(112) There is not enough space on the disk." zobrazili pouze
tlaèítko OK, nedáme uivateli monost problém odstranit a operaci dokonèit. Taková
chyba by mìla mít tlaèítka Retry/Skip/Skip all/Cancel. Stejná situace nastane,
pokud bìhem pakování velkého mnoství souborù nemùeme nìkterı soubor pøeèíst.
Pokud v chybové hlášce nenabídneme tlaèítko Skip/Skip all, bude celá operace
znehodnocena.

Ve vìtšinì pøípadù tedy uplatníme scénáø (3) s maximálním komfortem pro uivatele.
Pokud (3) nemá smysl, pouijeme zjednodušenı scénáø (2). Ve speciálních pøípadech
pouijeme tichı scénáø (1).

Kvalitní ošetøení chybovıch stavù I/O operací není úplnì triviální a znaènì
znepøehledòuje zbytek kódu (vnoøené cykly, pøípadnì tvrdé skoky pro Retry).
Z tohoto dùvodu jsme zavedli sadu funkcí øešící nejèastìjší problémy a sdruili
je pod rozhraní CSalamanderSafeFileAbstract. Funkce to nejsou nijak pìkné
(ani uvnitø, ani díky mnoství parametrù), ale problém øeší. Podrobnosti
k jejich pouití najdete v komentáøích v souboru spl_file.h. 
Do rozhraní jsme pøestìhovali i starou a ošklivou metodu SafeCreateFile.

Pokud budete I/O operace øešit vlastní silou, rádi dodáme zdrojové kódy, kde je
vidìt øešení rùznıch nástrah, na které jsme pøišli bìhem provozu Salamandera.
Napøíklad metody SafeFileRead a SafeFileWrite v pøípadì chyby a stisku tlaèítka
Retry zavírají handle souboru a pokoušejí se ho znovu otevøít. Dùvodem jsou
chyby na síti, kdy i po obnovení pøetreného spojení není starı handle funkèní
a jeho zavøení a nové otevøení je jediná monost, jak na operaci navázat.
Samozøejmì to znamená spravné nastavení ukazovátka v souboru atd.

Nìkolik pravidel k zobrazovanım chybám. (Pokud pouijete pro práci se soubory
rozhraní CSalamanderSafeFileAbstract, dostanete ošetøení vìtšiny chyb zdarma.)

-Pokud vznikne chyba, snaíme se jí správnì pojmenovat. Napøíklad nepíšeme 
 suché "Error", ale "Error Reading File".
 
-Pokud je k dispozici hodnota z API GetLastError, zobrazujeme ji pøed chybovou
 hláškou (Error: (5) Access is denied.). Pokud nám napøíklad italskı uivatel
 pošle screenshot nebo pøepis chybového hlášení v italštinì, dokáeme z èíselné
 reprezentace zjistit, o jakou chybu se jedná.
 
-Chyby se snaíme zobrazovat ve stejné formì, v jaké je zobrazuje Salamander
 bìhem jeho vestavìnıch operací (pokud Salamander takové precedenty má).
 Vìtšinou tedy nepouijeme obyèejnı MessageBox, ale mocnìjší DialogError, 
 DialogOverwrite nebo DialogQuestion. Tyto dialogy mimo jiné øeší zkrácení
 pøíliš dlouhého názvu souboru, kterı by MessageBox natáhnul.
 
-Snaíme se zobrazit název souboru, ve kterém k chybì došlo. Mnoho operací
 pracuje minimálnì nad dvìma soubory (zdroj a cíl), take pojmenování souboru
 v chybovém hlášení usnadní uivatelùm navigaci.

-Pokud chyba vznikla v dùsledku nekompatibilního formátu (napøíklad jsme v
 archivu nenašli centrální adresáø nebo je danı soubor zabalen neznámou kompresní
 metodou nebo data prostì nejsou tam kde by bıt mìla), opìt se snaíme problém 
 pøesnì pojmenovat místo suché hlášky "Error". Ušetøí nám to hromadu vrásek 
 v budoucnosti, a nám uivatelé chyby zaènou posílat zpìt.

Pokud si bìhem implementace nebudete jistí, jak by se plugin v dané situaci mìl
chovat, zkuste navodit obdobnou situaci bìhem nìkteré z vestavìnıch operací 
Salamandera. Pøípadnì nás kontaktujte a rozhodneme se jak situaci øešit.


15. Minimalizace fragmentování disku bìhem zápisu souborù
=========================================================
Soubory nejsou na disku vìtšinou uloeny vcelku, ale po èástech. Tento jev
se oznaèuje jako fragmentace souborù a má nepøíznivı dopad na rychlost diskovıch
operací. K fragmentaci dochází z podstaty souborového systému: na disku vzniknou
postupnì soubory A, B1, C; potom soubor B1 smaeme a zùstane po nìm díra, která 
je vyuitá novì vznikajícím souborem B2. Ten je však vìtší a co se nevejde do díry
po B1, bude pøipojeno do volného prostoru za souborem C. 

Pokud má bıt fragmentovanı soubor B2 následnì naèten do pamìti, musí disk
po naètení první èásti vystavit hlavièky do èásti druhé. Tím se sniuje
rychlost ètení. Operaèní systémy se snaí problém fragmentace rešit softy,
jako je Disk Defragmentator pod W2K. Tyto utility pøeskupí soubory tak, 
aby byly uloeny na disku vcelku. Disk Defragmentator dokáe na tlaèítko
Analyze posoudit míru fragmentace souborù, volného místa a zobrazit seznam
nejfragmentovanìjších souborù (vèetnì poètu fragmentù). 

Poèet fragmentù souborù lze zobrazit také pomocí naší utilitky fragment.exe,
která je k dispozici na vıvojáøské stránce. Rozumnı poèet fragmentù vytváøeného
souboru je jeden nebo dva. Zkuste pøípadnì pøíkaz Copy v Salamanderu 2.5 nebo
novìjším. Mìli byste se na daném disku dostat na stejnı poèet fragmentù.

Klasickı zpùsob ukládání dat do souboru vypadá takto:
  CreateFile    // vytvorime/prepiseme soubor
    WriteFile   // zapiseme buffer
    WriteFile   // zapiseme buffer
    ...
    WriteFile   // zapiseme posledni cast dat
  CloseFile

Operaèní systém pøedem nezná finální velikost vznikajícího souborù, take
se øídí velikostí zapisovaného bufferu pøedávaného do funkce WriteFile. Postupnì
se tak vyplòují díry mezi soubory. Pøi bìném provozu disku je volné místo
èasto fragmentované a novì vznikající soubor tedy bude také fragmentovanı. 
Salamander do verze 2.5 bìhem nakopírovaní 700MB souboru na disk bìnì
vytvoøil soubor sloenı z tisíce fragmentù. Problém se projevoval také bìhem
zápisu velkıch souborù na disketu nebo jiné pomalé médium. Pokud soubor zapisujeme
napøíklad po 60KB blocích, musí OS po zapsání kadého bloku pøemístit hlavièku do
FAT a zanést informaci o novì alokovanıch clusterech. Pokud pomineme devastaci
mechaniky, je tato metoda velmi pomalá a hluèná.

Pokud pøedem známe vıslednou velikost souboru, mùeme pouít
LEPŠÍ ZPÙSOB zápisu souboru:

  CreateFile              // vytvorime/prepiseme soubor
    SetFilePointer(END)   // ukazovatko nastavime na konec souboru
    SetEndOfFile          // nechame OS nafouknout soubor
    SetFilePointer(BEGIN) // ukazovatko vratime na zacatek souboru
    WriteFile             // zapiseme buffer
    WriteFile             // zapiseme buffer
    ...
    WriteFile             // zapiseme posledni cast dat
  CloseFile

OS nám pomoci funkce SetFilePointer umoòuji vystavit ukazovátko i do míst
"za koncem souboru". Funkce SetEndOfFile pak slouí jako commit, kterım poádáme
systém, aby pro soubor zabral volné clustery a provedl zápis do FAT nebo
jejího ekvivalentu. Protoe je známa vısledná velikost, mùe OS provést
alokaci volného místa efektivnìji a vıslednı soubor bude minimálnì
fragmentovanı (za pøedpokladu, e existuje dostatek nefragmentovaného volného
místa, co vetšinou platí).

Popsaná technika má nìkolik nástrah proti bìnému zpùsobu zápisu:
(1) Soubor se po celou dobu zápisu jeví jako kompletní, co mùe zmást uivatele.
(2) Pokud bìhem zápisu dojde k chybì nebo pøerušení operace uivatelem, je potøeba 
    zapisovanı soubor zkrátit na úroveò zapsanıch dat nebo na nulovou velikost, 
    protoe jinak OS uloí data od aktualního ukazovátka do konce souboru. Dobøe
    viditelné to je na disketách, kde po zavolání CloseHandle systém ještì patnáct
    vteøin ukládal "náhodná" data, aby vyplnil pøedalokovanı soubor. V pøípadì
    predèasného ukonèení tedy voláme:
      SetEndOfFile(hFile);                        // zkratime soubor na zapsanou velikost
      CloseHandle(hFile)                          // nyni uz ho muzeme zavrit
(3) SetEndOfFile techniku nemá smysl pouít v pøípadì, e vısledná velikost souboru
    je menší nebo rovna velikosti bufferu pro zápis.
(4) Máme zdokumentovanı pøípad, kdy na síovém disku neprojde operace
    SetFilePointer(BEGIN) a následnì zapsaná data ze pøipojí na konec souboru.
    Tento problém proto explicitnì testujeme na prvním souboru dávky a pokud ho detekujeme,
    zakáeme SetEndOfFile optimalizaci pro všechny soubory v této várce (napøíklad
    rozbalované soubory smìøující do jedné destinace).
(5) Pokud na cílovém disku není dostatek místa, metoda sele a stejnì jako ve (4)
    zapisujeme klasickou postupnou metodou.
    
Technika pøedalokace místa ve vytváøeném souboru je podpoøena rozhraním
CSalamanderSafeFileAbstract, viz funkce SafeFileCreate a její parametr 'allocateWholeFile'. 
Pouití je vidìt v pluginu UnFAT. Pokud se rozhodnete pro vlastní implementaci, poádejte
si o zdrojové kódy od CSalamanderSafeFileAbstract.


16. Èeho se vyvarovat bìhem implementace archivátoru
====================================================
Pozor na globální promìnné, které by èasem mohly bıt pøekákou pøi rozšiøování
architektury pluginù. Jedná se napøíklad o souèasné spouštìní metod pluginù, které
by zpùsobovalo pøepisování takovıch globálních promìnnıch. 

Kontext archivu dríme navázanı na CPluginDataInterfaceAbstract, take tady nebezpeèí
nehrozí. Pokud bychom kontext dreli v globální promìnné, narazíme ji v souèasné
verzi Salamandera, protoe jeden archivátor mùe bıt souèasnì zastoupen v levém i
pravém panelu a docházelo by ke kolizi. 

Funkce plnící a vracející øetìzec nenecháme vracet ukazatel na statickı buffer,
ale øetìzec do nich pøedáme jako parametr, spoleènì s jeho maximálním poètem
znakù.


17. Testování archivátorù
=========================
Jak rostl poèet implementací pluginu typu archivátor, naráeli jsme bìhem jejich
testování stále na stejnou skupinu problémù. Tyto nejèastìjší problémy jsme popsali
v souboru checklist.txt, aby je mohl snadno odstranit pøímo autor pluginu.
